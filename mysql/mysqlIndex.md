## MySQL Index 
**Alibaba(Python Senior Software Developer Engineer)Interview**  
### MySQL聚簇索引和非聚簇索引(也叫二级索引)  
- 聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。  
- 特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。  
- 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。  
- MYISAM是按列值与行号来组织索引的。它的叶子节点中保存的实际上是指向存放数据的物理块的指针。  
- InnoDB按聚簇索引的形式存储数据,聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC)和余下的列。  
- INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。  
- InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是数据的物理地址。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。  
- 以下是一些概念的理解：  
```
innodb索引分类：
聚簇索引(clustered index)
    1)  有主键时，根据主键创建聚簇索引
    2)  没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
    3) 如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引
辅助索引(secondary index)
   非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引
```
```
主键索引
主键索引就是唯一索引，不过主键索引是在创建表时就创建了，唯一索引可以随时创建。

说明
主键和唯一索引区别
     1) 主键是主键约束+唯一索引
     2) 主键一定包含一个唯一索引，但唯一索引不是主键
     3) 唯一索引列允许空值，但主键列不允许空值
     4) 一个表只能有一个主键，但可以有多个唯一索引
```
```
聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多。
相比之下，聚簇索引适合排序，非聚簇索引（也叫二级索引）不适合用在排序的场合。  
因为聚簇索引本身已经是按照物理顺序放置的，排序很快。非聚簇索引则没有按序存放，需要额外消耗资源来排序。  
当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
另外，二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，
从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据。
```
```
以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，
则又往前翻。这本书本身就是一个索引，即“聚簇索引”。
如果要找"fire"这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，
再找到"fire"，对应的会是它在第几课。这个附录，为“非聚簇索引”。
由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。

InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。
非聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。为什么存放的主键，
而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。

** 至于为什么主键通常建议使用自增id呢？**

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也
是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，
不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。

但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。
聚簇索引不但在检索上可以大大滴提高效率，在数据读取上也一样。比如：需要查询f~t的所有单词。
一个使用MyISAM的主索引，一个使用InnoDB的聚簇索引。两种索引的B+Tree检索时间一样，但读取时却有了差异。
因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，
按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。

不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，
因为索引所占空间小，这些操作是需要在内存中完成的。

鉴于聚簇索引的范围查询效率，很多人认为使用主键作为聚簇索引太多浪费，毕竟几乎不会使用主键进行范围查询。
但若再考虑到聚簇索引的存储，就不好定论了。
```
### mysql 索引结构(B+树结构，实际有三层，三层的原因是磁盘连续存放)  
- 几种树形结构：  
```
  1.搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构。  
  
  2.B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：
  ┌m/2┐ - 1 <= j <= m - 1；一个节点的子节点数量会比关键字个数多1，这样关键字就变成了子节点的分割标志。
  一般会在图示中把关键字画到子节点中间，非常形象，也容易和后面的B+树区分。
  由于数据同时存在于叶子节点和非叶子结点中，无法简单完成按顺序遍历B树中的关键字，必须用中序遍历的方法。
  
  3.B+树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：  
    ┌m/2┐ - 1 <= j <= m；子树的个数最多可以与关键字一样多。非叶节点存储的是子树里最小的关键字。  
  
  同时数据节点只存在于叶子节点中，且叶子节点间增加了横向的指针，这样顺序遍历所有数据将变得非常容易。  
  
  4.B*树：一棵m阶B树是一棵平衡的m路搜索树。最重要的两个性质是1每个非根节点所包含的关键字个数 j 满足：  
    ┌m2/3┐ - 1 <= j <= m；2非叶节点间添加了横向指针。   
```
![几种树形结构1](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure1.png)  
![几种树形结构2](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure2.png)  
![几种树形结构3](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure3.png)  
- B/B+/B*三种树的插入分裂方式  
>1. B树的分裂  
>> 下图的红色值即为每次新插入的节点。每当一个节点满后，就需要发生分裂（分裂是一个递归过程，参考下面7的插入导致了两层分裂），  
>> 由于B树的非叶子节点同样保存了键值，所以已满节点分裂后的值将分布在三个地方：1原节点，2原节点的父节点，3原节点的新建兄弟节点（参考5，7的插入过程）。  
>> 分裂有可能导致树的高度增加（参考3，7的插入过程），也可能不影响树的高度（参考5，6的插入过程）。  
![B树的分裂](https://github.com/hatcherfang/Database/blob/master/mysql/img/B_tree_divide.png)    
>2. B+树的分裂  
>> 当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；  
>> B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟节点的指针。  
![B+树的分裂](https://github.com/hatcherfang/Database/blob/master/mysql/img/Bplus_tree_divide.png)    
>3. B*树的分裂  
>> 当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，  
>> 最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）。如果兄弟也满了，
>> 则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。  
>> 可以看到B*树的分裂非常巧妙，因为B*树要保证分裂后的节点还要2/3满，如果采用B+树的方法，  
>> 只是简单的将已满的节点一分为二，会导致每个节点只有1/2满，这不满足B*树的要求了。  
>> 所以B*树采取的策略是在本节点满后，继续插入兄弟节点（这也是为什么B*树需要在非叶子节点加一个兄弟间的链表），  
>> 直到把兄弟节点也塞满，然后拉上兄弟节点一起凑份子，自己和兄弟节点各出资1/3成立新节点，这样的结果是3个节点刚好是2/3满，达到B*树的要求，皆大欢喜。  
![B*树的分裂](https://github.com/hatcherfang/Database/blob/master/mysql/img/Bbit_tree_divide.png)    

- 树结构的选择  
> B+树适合作为数据库的基础结构，完全是因为计算机的内存-机械硬盘两层存储结构。  
> 内存可以完成快速的随机访问（随机访问即给出任意一个地址，要求返回这个地址存储的数据）但是容量较小。  
> 而硬盘的随机访问要经过机械动作（1磁头移动 2盘片转动），访问效率比内存低几个数量级，但是硬盘容量较大。  
> 典型的数据库容量大大超过可用内存大小，这就决定了在B+树中检索一条数据很可能要借助几次磁盘IO操作来完成。  
> 如下图所示：通常向下读取一个节点的动作可能会是一次磁盘IO操作，不过非叶节点通常会在初始阶段载入内存以加快访问速度。  
> 同时为提高在节点间横向遍历速度，真实数据库中可能会将图中蓝色的CPU计算/内存读取优化成二叉搜索树（InnoDB中的page directory机制）。  
![B+树检索过程](https://github.com/hatcherfang/Database/blob/master/mysql/img/Bplus_tree_search.png)    

Example:  
```
 真实数据库中的B+树应该是非常扁平的，可以通过向表中顺序插入足够数据的方式来验证InnoDB中的B+树到底有多扁平。
我们通过如下图的CREATE语句建立一个只有简单字段的测试表，然后不断添加数据来填充这个表。通过下图的统计数据（来源见参考文献1）
可以分析出几个直观的结论，这几个结论宏观的展现了数据库里B+树的尺度。
   1.每个叶子节点存储了468行数据，每个非叶子节点存储了大约1200个键值，这是一棵平衡的1200路搜索树！
   2.对于一个22.1G容量的表，也只需要高度为3的B+树就能存储了，这个容量大概能满足很多应用的需要了。如果把高度增大到4，
则B+树的存储容量立刻增大到25.9T之巨！
   3.对于一个22.1G容量的表，B+树的高度是3，如果要把非叶节点全部加载到内存也只需要少于18.8M的内存
（如何得出的这个结论？**因为对于高度为2的树，1203个叶子节点也只需要18.8M空间，而22.1G从良表的高度是3，非叶节点1204个。
同时我们假设叶子节点的尺寸是大于非叶节点的，因为叶子节点存储了行数据而非叶节点只有键和少量数据**。），
只使用如此少的内存就可以保证只需要一次磁盘IO操作就检索出所需的数据，效率是非常之高的。
```
![扁平的B+树](https://github.com/hatcherfang/Database/blob/master/mysql/img/flat_Bplus_tree.png)    

- Mysql的存储引擎和索引  
> 可以说数据库必须有索引，没有索引则检索过程变成了顺序查找，O(n)的时间复杂度几乎是不能忍受的。  
> 我们非常容易想象出一个只有单关键字组成的表如何使用B+树进行索引，只要将关键字存储到树的节点即可。  
> 当数据库一条记录里包含多个字段时，一棵B+树就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。  
> 这时应该在第二个要检索的列上建立第二套索引。  
> 这个索引由独立的B+树来组织。有两种常见的方法可以解决多个B+树访问同一套表数据的问题，  
> 一种叫做聚簇索引（clustered index ），一种叫做非聚簇索引（secondary index）。  
> 这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。  
> 对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。  
> 对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。  
>>1. InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，  
>> 则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，  
>> 到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。  
>>2. MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，  
>> 辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。  
>> 由于索引树是独立的，通过辅助键检索无需访问主键的索引树。  
>>3. 为了更形象说明这两种索引的区别，我们假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。  
![example table](https://github.com/hatcherfang/Database/blob/master/mysql/img/table.png)  
![clusterAndNonclusterIndex](https://github.com/hatcherfang/Database/blob/master/mysql/img/clusterAndNonclusterIndex.png)  
```
 我们重点关注聚簇索引，看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？
   1. 由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
   2. 辅助索引使用主键作为"指针" 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，
   换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化
  （前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。
```

- InnoDB的Page结构  
```
 理解InnoDB的实现不得不提Page结构，Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，
与数据库相关的所有内容都存储在这种Page结构里。  

Page分为几种类型，常见的页类型有数据页（B-tree Node）Undo页（Undo Log Page）系统页（System Page） 
事务数据页（Transaction System Page）等。  

单个Page的大小是16K（编译宏UNIV_PAGE_SIZE控制），每个Page使用一个32位的int值来唯一标识，
这也正好对应InnoDB最大64TB的存储容量（16Kib * 2^32 = 64Tib）。   
```

Related Tutorials:  
1. MySQL聚簇索引和非聚簇索引(也叫二级索引)   
[http://www.cnblogs.com](http://www.cnblogs.com/T8881/p/5940338.html)  
[http://blog.csdn.net/bigtree_3721](http://blog.csdn.net/bigtree_3721/article/details/51335479)  
[http://blog.csdn.net/lijiaz5033](http://blog.csdn.net/lijiaz5033/article/details/50129723)  
2. mysql 索引结构(B+树结构，实际有三层，三层的原因是磁盘连续存放)   
[http://bijian1013.iteye.com](http://bijian1013.iteye.com/blog/2315666)  
