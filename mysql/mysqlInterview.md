## MySQL Interview  
#### Alibaba Python Senior Software Developer Engineer  
1. MySQL聚簇索引和非聚簇索引(也叫二级索引)  
- 聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。  
- 特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。  
- 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。  
- MYISAM是按列值与行号来组织索引的。它的叶子节点中保存的实际上是指向存放数据的物理块的指针。  
- InnoDB按聚簇索引的形式存储数据,聚簇索引中的每个叶子节点包含主键值、事务ID、回滚指针(rollback pointer用于事务和MVCC)和余下的列。  
- INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。  
- InnoDB的的二级索引的叶子节点存放的是KEY字段加主键值。因此，通过二级索引查询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。而MyISAM的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是数据的物理地址。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。  
- 以下是一些概念的理解：  
```
innodb索引分类：
聚簇索引(clustered index)
    1)  有主键时，根据主键创建聚簇索引
    2)  没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
    3) 如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引
辅助索引(secondary index)
   非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引
```
```
主键索引
主键索引就是唯一索引，不过主键索引是在创建表时就创建了，唯一索引可以随时创建。

说明
主键和唯一索引区别
     1) 主键是主键约束+唯一索引
     2) 主键一定包含一个唯一索引，但唯一索引不是主键
     3) 唯一索引列允许空值，但主键列不允许空值
     4) 一个表只能有一个主键，但可以有多个唯一索引
```
```
聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多。
相比之下，聚簇索引适合排序，非聚簇索引（也叫二级索引）不适合用在排序的场合。  
因为聚簇索引本身已经是按照物理顺序放置的，排序很快。非聚簇索引则没有按序存放，需要额外消耗资源来排序。  
当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
另外，二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，
从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据。
```
```
以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，
则又往前翻。这本书本身就是一个索引，即“聚簇索引”。
如果要找"fire"这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，
再找到"fire"，对应的会是它在第几课。这个附录，为“非聚簇索引”。
由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。

InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引。
非聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。为什么存放的主键，
而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。

** 至于为什么主键通常建议使用自增id呢？**

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也
是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，
不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。

但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。
聚簇索引不但在检索上可以大大滴提高效率，在数据读取上也一样。比如：需要查询f~t的所有单词。
一个使用MyISAM的主索引，一个使用InnoDB的聚簇索引。两种索引的B+Tree检索时间一样，但读取时却有了差异。
因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，
按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。

不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，
因为索引所占空间小，这些操作是需要在内存中完成的。

鉴于聚簇索引的范围查询效率，很多人认为使用主键作为聚簇索引太多浪费，毕竟几乎不会使用主键进行范围查询。
但若再考虑到聚簇索引的存储，就不好定论了。
```
2. mysql 索引结构(B+树结构，实际有三层，三层的原因是磁盘连续存放)  
- 几种树形结构：  
```
1.搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构。  

2.B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：
┌m/2┐ - 1 <= j <= m - 1；一个节点的子节点数量会比关键字个数多1，这样关键字就变成了子节点的分割标志。
一般会在图示中把关键字画到子节点中间，非常形象，也容易和后面的B+树区分。
由于数据同时存在于叶子节点和非叶子结点中，无法简单完成按顺序遍历B树中的关键字，必须用中序遍历的方法。

3.B+树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：  
  ┌m/2┐ - 1 <= j <= m；子树的个数最多可以与关键字一样多。非叶节点存储的是子树里最小的关键字。  

同时数据节点只存在于叶子节点中，且叶子节点间增加了横向的指针，这样顺序遍历所有数据将变得非常容易。  

4.B*树：一棵m阶B树是一棵平衡的m路搜索树。最重要的两个性质是1每个非根节点所包含的关键字个数 j 满足：  
  ┌m2/3┐ - 1 <= j <= m；2非叶节点间添加了横向指针。   
```
![几种树形结构1](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure1.png)  
![几种树形结构2](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure2.png)  
![几种树形结构3](https://github.com/hatcherfang/Database/blob/master/mysql/img/trees_structure3.png)  
- InnoDB的Page结构  
```
 理解InnoDB的实现不得不提Page结构，Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，
与数据库相关的所有内容都存储在这种Page结构里。  

Page分为几种类型，常见的页类型有数据页（B-tree Node）Undo页（Undo Log Page）系统页（System Page） 
事务数据页（Transaction System Page）等。  

单个Page的大小是16K（编译宏UNIV_PAGE_SIZE控制），每个Page使用一个32位的int值来唯一标识，
这也正好对应InnoDB最大64TB的存储容量（16Kib * 2^32 = 64Tib）。   
```



Related Tutorials:  
1. MySQL聚簇索引和非聚簇索引(也叫二级索引)   
[http://www.cnblogs.com](http://www.cnblogs.com/T8881/p/5940338.html)  
[http://blog.csdn.net/bigtree_3721](http://blog.csdn.net/bigtree_3721/article/details/51335479)  
[http://blog.csdn.net/lijiaz5033](http://blog.csdn.net/lijiaz5033/article/details/50129723)  
